#!/usr/bin/perl

use strict;
use warnings;
use lib qw( . .. lib ../lib );
use saR;
use Pod::Usage;
use Carp;
use Data::Dumper;

use Getopt::Long qw(:config bundling);

use vars qw( $s );

=head1 NAME

saRdump - Dump data in a usable form from sar text files

=head1 USAGE

  saRdump [-d dir1,dir2] [-e txt] -H -C -D [-c "proc/s,INTR:*,CPU:%user,CPU:%sys"] [ machine1 ... ]

=head1 REQUIRED ARGUMENTS

None.
By default, all files ending with extension C<txt> in current directory
will be used as machines sar data files.

=head1 OPTIONS

The following options are supported:

=over 4

=item * -d dir1,dir2

Comma separated list of directories to search for data files.

Default: C<.>

B<Caveat:> Jokers are allowed here, and will be extended using glob. You
will hence need to protect them from the shell expanding them by
escaping them.

=item * -e <ext1,ext2>

Comma separated list of file extensions to match a data file name.

Default: C<txt>

=item * -I

Dump machine info found in the header (not really sar) if any.

=item * -C

Dump sar data column headers found in the file on stderr output.

=item * -D 

Dump data into csv files per index type.

=item * -c cols

Only dumps those data columns in resulting files.

=cut

# 
# analyze options
#
my ($extensions, $dirs, $cols);
my ($dump_info, $dump_data, $dump_headers) = (0, 0, 0);
# Set defaults
$extensions = 'txt';
$dirs = '.';
$cols = '';

my $result = GetOptions(
    'e|extensions=s' => \$extensions,
    'd|dirs=s'       => \$dirs,
    'c|cols=s'       => \$cols,
    'I|info'         => \$dump_info,
    'C|headers'      => \$dump_headers,
    'D|data'         => \$dump_data,
  )
  or pod2usage(
    -exitval => 254,
    -verbose => 99,
  );

my @dirs = split( qr{,}, $dirs );
# expand globs in dirs
@dirs = map { glob( $_ ) } @dirs;
my @exts = split qr{,}, $extensions;

my $s = saR->new( dir => \@dirs, ext => \@exts);

if (defined $ENV{DEBUG} ) {
    print Dumper $s;
}


my @info = qw(hwmodel cpumodel cpus cores ram oslevel san);

print STDERR "Starting main\n";
# 
# Dump base info
#
if ($dump_info) {
    print STDERR "Base info\n";
    # get base info
    my %base_info = $s->base_info();

    # dump it.
    foreach my $m ( keys %base_info ) {
        my %bi = %{ $base_info{$m} };
        print join ';', $m, @bi{@info};

        print "\n";
    }
}



